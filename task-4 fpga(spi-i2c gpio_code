module gpio_soc#(
    parameter N = 32
)(
    input              clk,
    input              rst_n,

    // simple memory-mapped bus
    input              bus_wr,
    input              bus_rd,
    input      [5:0]   bus_addr,
    input      [31:0]  bus_wdata,
    output reg [31:0]  bus_rdata,

    // GPIO
    input  [N-1:0] gpio_in,
    output [N-1:0] gpio_out,
    output [N-1:0] gpio_oe,

    // interrupt
    output irq
);


// 2-FF synchronizer


reg [N-1:0] sync1, sync2;

always @(posedge clk or negedge rst_n) begin
    if(!rst_n) begin
        sync1 <= 0;
        sync2 <= 0;
    end else begin
        sync1 <= gpio_in;
        sync2 <= sync1;
    end
end

wire [N-1:0] gpio_sync = sync2;


// Registers


reg [N-1:0] dir;
reg [N-1:0] out_reg;
reg [N-1:0] int_en;
reg [N-1:0] int_status;

assign gpio_out = out_reg;
assign gpio_oe  = dir;


// Edge detection (rising edge interrupt)


reg [N-1:0] prev_sync;

always @(posedge clk or negedge rst_n) begin
    if(!rst_n)
        prev_sync <= 0;
    else
        prev_sync <= gpio_sync;
end

wire [N-1:0] rising_edge =
        gpio_sync & ~prev_sync;


// Interrupt status logic


always @(posedge clk or negedge rst_n) begin
    if(!rst_n)
        int_status <= 0;
    else begin
        int_status <= int_status | rising_edge;

        if(bus_wr && bus_addr == 6'h1C)
            int_status <= int_status & ~bus_wdata[N-1:0];
    end
end

assign irq = |(int_status & int_en);


// Register write logic


always @(posedge clk or negedge rst_n) begin
    if(!rst_n) begin
        dir      <= 0;
        out_reg  <= 0;
        int_en   <= 0;
    end else if(bus_wr) begin
        case(bus_addr)

        6'h00: dir <= bus_wdata[N-1:0];
        6'h04: out_reg <= bus_wdata[N-1:0];

        6'h0C: out_reg <= out_reg | bus_wdata[N-1:0];
        6'h10: out_reg <= out_reg & ~bus_wdata[N-1:0];
        6'h14: out_reg <= out_reg ^ bus_wdata[N-1:0];

        6'h18: int_en <= bus_wdata[N-1:0];

        default: ;
        endcase
    end
end


// Register read logic


always @(*) begin
    case(bus_addr)
    6'h00: bus_rdata = dir;
    6'h04: bus_rdata = out_reg;
    6'h08: bus_rdata = gpio_sync;
    6'h18: bus_rdata = int_en;
    6'h1C: bus_rdata = int_status;
    default: bus_rdata = 32'h0;
    endcase
end

endmodule
